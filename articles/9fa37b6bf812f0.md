---
title: "df-pnアルゴリズムをRustで実装して公開しました"
emoji: "♟️"
type: "tech"
topics: ["将棋", "dfpn", "Rust"]
published: false
---

[やねうら王](https://yaneuraou.yaneu.com/2024/05/08/all-about-df-pn/)さんの記事が話題になっていたので、以前 Rust で実装した df-pn アルゴリズムの実装を整理して公開しました。
リポジトリは[こちら](https://github.com/malt03/df-pn-rust)です。

正直、個人的に C++や Python のコードはとても追いづらくて辛いので Rust で書いた df-pn の実装が少しでも役立てば幸いです。

# 使い方

[README](https://github.com/malt03/df-pn-rust/blob/main/README.md)にも書いた通りですが、将棋の盤面を AA で書いたファイルを引数に渡すと詰み盤面を探索します。
試してみた感じ、9 手詰めはサラリと解けるんですが、11 手詰めは 10 万回探索しても解けませんでした。

[出力例](https://app.warp.dev/block/embed/z61ATQXsnmLISlUR9nh7jj)

```
cargo run --release -- ./examples/nine.txt
```

![探索](https://storage.googleapis.com/zenn-user-upload/5a7efd2c5eb7-20240512.png =250x)

# せっかくなので df-pn の解説

df-pn アルゴリズムは一見難しそうですが、コアの概念は全然難しくありません。
重要なのは以下の一点のみです。

:::message
攻方も玉方も、相手が打てる手が少なくなる手を打つ
:::

ありがちな df-pn アルゴリズムの実装として「攻方は pn が小さくなるように、玉方は dn が小さくなるようにする」というのがありますが、これがとても混乱しやすいです。
計算式も逆にせねばならず、実装も複雑になります。

わかりやすい実装としては、お互いに相手方の df から pn を計算し、pn から df を計算します。そうすることで、双方ともに pn を小さくすることを目標にすることができるので、実装もシンプルになります。
攻方の pn が 0 になったらその盤面は詰みが証明され、玉方の pn が 0 になったら、その盤面は不詰みが証明されます。

```rust
pub(crate) fn update_reversed(&mut self, other: &PnDn) {
    if other.dn < self.pn {
        self.pn = other.dn;
    }
    self.dn = self.dn.saturating_add(other.pn);
}
```
