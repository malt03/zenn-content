---
title: "Node.jsで可逆暗号"
emoji: "🗝️"
type: "tech"
topics: ["Nodejs", "TypeScript", "ChatGPT"]
published: false
---

Node.js で可逆暗号を扱うためのいい感じの記事が意外に見当たらなかったので書いておく。
平文で保管したくない文字列を暗号化する場合に使うことを想定した実装になっている。

```typescript:crypto.ts
import crypto from "crypto";

const algorithm = "aes-256-ctr";
const secretKeyHex = process.env["SECRET_KEY"];
if (secretKeyHex === undefined) throw new Error("SECRET_KEY is not defined");
const secretKey = Buffer.from(secretKeyHex, "base64");

export const encrypt = (plain: string, secretKey: Buffer) => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(algorithm, secretKey, iv);
  const encrypted = Buffer.concat([cipher.update(plain, "utf8"), cipher.final()]);

  return Buffer.concat([iv, encrypted]).toString("base64");
};

export const decrypt = (encrypted: string, secretKey: Buffer) => {
  const data = Buffer.from(encrypted, "base64");
  const iv = data.slice(0, 16);
  const value = data.slice(16);

  const decipher = crypto.createDecipheriv(algorithm, secretKey, iv);
  const decrypted = Buffer.concat([decipher.update(value), decipher.final()]);

  return decrypted.toString("utf8");
};
```

```typescript:generate-secret-key.ts
import crypto from "crypto";

console.log(crypto.randomBytes(32).toString("base64"));
```

# 参考情報

## 暗号利用モードに何を使うべきか

とりあえず `AES-256` を使うのは確定事項として、暗号利用モードをどうすべきかがわかりづらい。
結論としては `CTR` を使うので良さそうなのだが、理由を書いておく。

[Wikipedia](https://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E5%88%A9%E7%94%A8%E3%83%A2%E3%83%BC%E3%83%89)の記事が詳しいが、様々なモードがある。
一番単純なモードが `ECB` であり、これはどうやら脆弱な部分があるようだ。
そこで開発されたのが `CBC` で、かなり一般的に利用されているが、並列処理ができないという弱点がある。
それをさらに並列処理できるようにしたのが `CTR` というのがまぁざっくりした理解として間違ってなさそう。

さらに、認証付き暗号というものがあるが、これは文字通り暗号文に認証性を持たせるためのモードで、中間者攻撃を受けることが想定されるような場合に利用すべきものらしい。

## hex か base64 か

計測してみたけど、意外にも base64 の方が有意に速そう。
もちろん実行環境やらなんやらの影響はあると思うが、M1 Mac では何度試しても base64 の方が速くなった。
個人的には、hex の方が何バイトあるか分かりやすくて好きなんだけど、これでは base64 を使わざるを得ない。
文字列としての長さも base64 の方が短いし。

```typescript
import crypto from "crypto";
import { measure, dump } from "./measure";

const buffers: Buffer[] = [];
for (let i = 0; i < 10000; i++) {
  buffers.push(crypto.randomBytes(64));
}

measure("base64", () => {
  for (let i = 0; i < 1000; i++) {
    for (const buffer of buffers) {
      const base64 = buffer.toString("base64");
      Buffer.from(base64, "base64");
    }
  }
});

measure("hex", () => {
  for (let i = 0; i < 1000; i++) {
    for (const buffer of buffers) {
      const hex = buffer.toString("hex");
      Buffer.from(hex, "hex");
    }
  }
});

dump();
```

```
% npx ts-node main.ts
base64 : 3082ms
hex : 3669ms
```

```typescript:measure.ts
export const measure = <T>(label: string, handler: () => T): T => {
  performance.mark("start");
  const result = handler();
  performance.mark("finish");
  performance.measure(label, "start", "finish");
  return result;
};
export const dump = () => console.info(performance.getEntriesByType("measure").map(({name, duration}) => `${name} : ${Math.floor(duration)}ms`).join("\n"));
```

## 蛇足（ChatGPT すごい）

Node.js で可逆暗号の実装を書くのは初めてだったので、ChatGPT に色々聞きながら進めたらとても捗った。
相変わらず ChatGPT のおかげで生産性が爆上がりしている。

![](https://storage.googleapis.com/zenn-user-upload/716ed7f9751e-20230420.png)
![](https://storage.googleapis.com/zenn-user-upload/89351934f9f5-20230420.png)
![](https://storage.googleapis.com/zenn-user-upload/fa4205e0b732-20230420.png)
